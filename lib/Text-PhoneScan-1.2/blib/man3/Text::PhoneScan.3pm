.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PhoneScan 3"
.TH PhoneScan 3 "2009-11-02" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::PhoneScan \- Find phone numbers in text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Text::PhoneScan;
\&  my $scanner = Text::PhoneScan\->new($text,
\&                                     scanners => [\*(AqMarked\*(Aq, \*(AqOftel\*(Aq, \*(AqUK\*(Aq]);
\&  my @numbers = $scanner\->numbers;
\&  my %numbers = $scanner\->numbers_by_scanner;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module examines a chunk of text and tries to return any telephone
numbers it finds. It has a pluggable back-end system which determines
which heuristics it uses to extract numbers.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new($text, scanners=>[...])"
.IX Subsection "new($text, scanners=>[...])"
This creates a new scanner with a given piece of text, and, optionally,
specifies which backend modules to use. Currently available scanners
are:
.IP "Marked" 3
.IX Item "Marked"
This tries to pick out numbers which are 'marked' in some way \- for
instance, prefixed by \*(L"Tel:\*(R" or \*(L"P:\*(R".
.IP "MagicWord" 3
.IX Item "MagicWord"
This tries to pick out numbers marked by 'magic words', such as \*(L"Call me
on \s-1XXX\s0 \s-1YYYYYY\s0\*(R".
.IP "Oftel" 3
.IX Item "Oftel"
Returns numbers which conform to the \s-1UK\s0's OfTel recommended layouts.
.IP "\s-1UK\s0" 3
.IX Item "UK"
Returns other numbers which match known \s-1UK\s0 exchanges.
.IP "International" 3
.IX Item "International"
Returns numbers which are begin \*(L"+\*(R" and a valid country code.
.IP "\s-1US\s0" 3
.IX Item "US"
Returns numbers which match known \s-1US\s0 and Canada exchanges.
.IP "France" 3
.IX Item "France"
Matches French phone numbers
.IP "NoISBN" 3
.IX Item "NoISBN"
Removes things which look more like ISBNs than phone numbers.
.IP "FixInt" 3
.IX Item "FixInt"
Normalises international dialing numbers \- inserts the \*(L"+\*(R" prefix where
it's missing, removes trunk codes, etc.
.IP "UKLocal" 3
.IX Item "UKLocal"
Returns \s-1UK\s0 local dialing numbers; this is the most vague of all.
.PP
The default set of scanners is pretty good, but errs on the side of
returning too many numbers rather than too few. If, for instance, you
know you're never going to be dealing with international phone numbers,
you may want to customise the list of scanners; remember that order is
important.
.Sh "numbers"
.IX Subsection "numbers"
Returns the phone numbers found in the text.
.Sh "numbers_by_scanner"
.IX Subsection "numbers_by_scanner"
Returns a hash with the phone numbers as the keys and the scanner which
found each number as the values.
.SH "AUTHOR"
.IX Header "AUTHOR"
Simon Cozens \f(CW\*(C`simon@kasei.com\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
